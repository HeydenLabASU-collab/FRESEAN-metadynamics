#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <omp.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_blas.h>
//#include <gsl/gsl_linalg.h>
#include <gsl/gsl_eigen.h>

int printTitle() {
        printf("THE PURPOSE OF THIS PROGRAM IS TO COMPUTE\n");
        printf("THE EIGENVALUES AND EIGENVECTORS FOR A LIST OF\n");
        printf("MATRICES GENERATED BY:\n");
        printf("gen-modes.exe OR gen-modes_omp.exe\n");
        printf("AN OPTIONAL PARAMETER ALLOWS TO PERFORM THIS\n");
        printf("FOR ONLY THE FIRST 'N' MATRICES IN THE LIST.\n");
        printf("Version 1.2: April 26, 2023\n");
        printf("Author:\n");
        printf(" Dr. Matthias Heyden\n");
        printf(" School of Molecular Sciences\n");
        printf(" Arizona State University\n");
        printf(" Tempe, AZ, USA\n");
        printf(" e-mail: mheyden1@asu.edu\n");
        printf("\n");
        return 0;
}

/* qsort double comparison function */
int double_cmp(const void *a, const void *b)
{
        int res;
        const double *ia = (const double *)a; /* casting pointer types  */
        const double *ib = (const double *)b;
        if(*ia-*ib<0.0)
        {
                res=-1;
        } else res=1;
        return res;
        /* double comparison: returns negative if b > a
        and positive if a > b */
}

/*USAGE OF QSORT*/
/* qsort(array,nelem,sizeof(arrayelem),oneOfTheFunctionsAbove); */

int exchangeEvec(gsl_matrix *ev,int n,int a,int b) {
        gsl_vector *tmp;
        double tmp1;
        int i,j;

        tmp=gsl_vector_alloc(n);
        for(i=0;i<n;i++) {
                tmp1=gsl_matrix_get(ev,i,a);
                gsl_vector_set(tmp,i,tmp1);
        }
        for(i=0;i<n;i++) {
                tmp1=gsl_matrix_get(ev,i,b);
                gsl_matrix_set(ev,i,a,tmp1);
        }
        for(i=0;i<n;i++) {
                tmp1=gsl_vector_get(tmp,i);
                gsl_matrix_set(ev,i,b,tmp1);
        }
        gsl_vector_free(tmp);
        return 0;
}

int eigen(gsl_matrix *A,gsl_vector *eval,gsl_matrix *ev,int n) {
        gsl_eigen_symmv_workspace *w;
        int res;
        double tmp1,tmp2;
        int i,j;
        int flag=1;
        int nEx=0;
        int nLoops=0;

        w=gsl_eigen_symmv_alloc(n);
        res=gsl_eigen_symmv(A,eval,ev,w);
        gsl_eigen_symmv_free(w);

        while(flag!=0) {
                flag=0;
                for(i=0;i<n-1;i++) {
                        tmp1=gsl_vector_get(eval,i);
                        tmp2=gsl_vector_get(eval,i+1);
                        if(tmp2>tmp1) {
                                //printf("Eigenvalues not ordered: l(%d)=%e > l(%d)=%e\n",i+1,tmp2,i,tmp1);
                                exchangeEvec(ev,n,i,i+1);
                                gsl_vector_set(eval,i,tmp2);
                                gsl_vector_set(eval,i+1,tmp1);
                                flag=1;
                                nEx++;
                        }
                }
                if(flag!=0) nLoops++;
        }
        printf("sorting eigenvalues (large to small) required %d loops and %d exchanges\n",nLoops,nEx);
        return res;
}

int main(int argc, char *argv[]) {
        FILE *io,*io2,*io3;
        char fnEvec[100];
        char fnEval[100];
        int i,j,k,c;
        int nCorr,n1,n2;
        double tmp;
        int bc1,bc2;
        int nMat;
        gsl_matrix **m;
        gsl_matrix **ev;
        gsl_vector **eval;
        int magic1,magic2;
        int chunk=64;
        int curChunk;

        printTitle();

        if(argc<2) {
                printf("usage: ./eigen.exe matrix.mmat [first N]\n");
                exit(1);
        }
        if(argc==3) {
                sscanf(argv[2],"%d",&nMat);
                printf("will read first %d matrices\n",nMat);
        }
        io=fopen(argv[1],"rb");
        fread(&bc1,sizeof(int),1,io);
        fread(&nCorr,sizeof(int),1,io);
        if(argc==3) nCorr=nMat;
        fread(&n1,sizeof(int),1,io);
        fread(&n2,sizeof(int),1,io);
        fread(&bc2,sizeof(int),1,io);

        if(bc2!=bc1) {
                printf("format error in file: %s\n",argv[1]);
                exit(1);
        }
        if(n1!=n2) {
                printf("matrices in file %s are not square: %d x %d\n",argv[1],n1,n2);
                exit(1);
        }
        printf("allocating 2 x %d matrices of dimension %d x %d\n",chunk,n1,n2);
        printf("allocating 1 x %d vectors  of dimension %d\n",chunk,n1);
        m=(gsl_matrix**)malloc(chunk*sizeof(gsl_matrix*));
        ev=(gsl_matrix**)malloc(chunk*sizeof(gsl_matrix*));
        eval=(gsl_vector**)malloc(chunk*sizeof(gsl_vector*));
        for(i=0;i<chunk;i++) {
                m[i]=gsl_matrix_alloc(n1,n2);
                ev[i]=gsl_matrix_alloc(n1,n2);
                eval[i]=gsl_vector_alloc(n1);
        }
        printf("done\n");

        /*opening file for Eigenvector output*/
        magic1=3*sizeof(int);
        magic2=n1*n2*sizeof(double);
        sprintf(fnEvec,"evec_%s",argv[1]);
        io2=fopen(fnEvec,"wb");
        fwrite(&magic1,sizeof(int),1,io2);
        fwrite(&nCorr,sizeof(int),1,io2);
        fwrite(&n1,sizeof(int),1,io2);
        fwrite(&n2,sizeof(int),1,io2);
        fwrite(&magic1,sizeof(int),1,io2);

        /*opening file for Eigenvalue output*/
        sprintf(fnEval,"eval_%s.dat",argv[1]);
        io3=fopen(fnEval,"w");

        for(c=0;c*chunk<nCorr;c++) {
                if((c+1)*chunk<nCorr) {
                        curChunk=chunk;
                } else {
                        curChunk=nCorr-c*chunk;
                }
                printf("reading %d matrices in chunk %d\n",curChunk,c+1);
                for(i=0;i<curChunk;i++) {
                        fread(&bc1,sizeof(int),1,io);
                        for(j=0;j<n1;j++) {
                                for(k=0;k<n2;k++) {
                                        fread(&tmp,sizeof(double),1,io);
                                        gsl_matrix_set(m[i],j,k,tmp);
                                }
                        }
                        fread(&bc2,sizeof(int),1,io);
                        if(bc2!=bc1) {
                                printf("format error in file: %s\n",argv[1]);
                                exit(1);
                        }
                        printf("%cfinished reading matrix %d of %d",(char)13,i+1,curChunk);fflush(stdout);
                }
                printf("\ndone\n"); fflush(stdout);
                printf("beginning diagonalization of %d matrices in chunk %d\n",curChunk,c+1);
                #pragma omp parallel for
                for(i=0;i<curChunk;i++) {
                        eigen(m[i],eval[i],ev[i],n1);
                        printf("%cdiagonalized matrix %d of %d",(char)13,i+1,curChunk);fflush(stdout);
                }
                printf("\ndone\n"); fflush(stdout);
                /*writing Eigenvectors for this chunk*/
                for(i=0;i<curChunk;i++) {
                        fwrite(&magic2,sizeof(int),1,io2);
                        for(j=0;j<n1;j++) {
                                for(k=0;k<n2;k++) {
                                        /*transposing matrix to get Eigenvectors at rows for easier access*/
                                        tmp=gsl_matrix_get(ev[i],k,j);
                                        fwrite(&tmp,sizeof(double),1,io2);
                                }
                        }
                        fwrite(&magic2,sizeof(int),1,io2);
                }
                /*writing Eigenvalues for this chunk*/
                for(i=0;i<curChunk;i++) {
                        for(j=0;j<n1;j++) {
                                tmp=gsl_vector_get(eval[i],j);
                                fprintf(io3," %e",tmp);
                        }
                        fprintf(io3,"\n");
                }
        }
        fclose(io);
        fclose(io2);
        fclose(io3);
        
        return 0;
}
